# Команда (Действие, Транзакция, Action, Command)

![Команда](https://github.com/PavelRudenya730501/Patterns/raw/master/pictures/command.png)

Команда — это поведенческий паттерн проектирования, который превращает запросы в объекты, позволяя передавать их как аргументы при
вызове методов, ставить запросы в очередь, логировать их, а также поддерживать отмену операций.

# Структура

![Команда. Структура](https://github.com/PavelRudenya730501/Patterns/raw/master/pictures/structure(command).png)

Отправитель хранит ссылку на объект команды и обращается к нему, когда нужно выполнить какое-то действие. Отправитель работает с
командами только через их общий интерфейс. Он не знает, какую конкретно команду использует, так как получает готовый объект команды
от клиента.

Команда описывает общий для всех конкретных команд интерфейс. Обычно здесь описан всего один метод для запуска команды.

Конкретные команды реализуют различные запросы, следуя общему интерфейсу команд. Обычно команда не делает всю работу самостоятельно, а
лишь передаёт вызов получателю, которым является один из объектов бизнес-логики. Параметры, с которыми команда обращается к получателю,
следует хранить в виде полей. В большинстве случаев объекты команд можно сделать неизменяемыми, передавая в них все необходимые
параметры только через конструктор.

Получатель содержит бизнес-логику программы. В этой роли может выступать практически любой объект. Обычно команды перенаправляют вызовы
получателям. Но иногда, чтобы упростить программу, вы можете избавиться от получателей, «слив» их код в классы команд.

Клиент создаёт объекты конкретных команд, передавая в них все необходимые параметры, среди которых могут быть и ссылки на объекты
получателей. После этого клиент связывает объекты отправителей с созданными командами.

# Диаграмма классов

![Command.class](https://github.com/PavelRudenya730501/Patterns/raw/master/pictures/command-diagram.png)

# Диаграмма последовательностей

![Command.Sequence](https://github.com/PavelRudenya730501/Patterns/raw/master/pictures/command-sequence.png)

 # Применимость
 
 ### @ Когда вы хотите параметризовать объекты выполняемым действием.
 
 ### @ Команда превращает операции в объекты. А объекты можно передавать, хранить и взаимозаменять внутри других объектов. Скажем, вы разрабатываете библиотеку графического меню и хотите, чтобы пользователи могли использовать меню в разных приложениях, не меняя каждый раз код ваших классов. Применив паттерн, пользователям не придётся изменять классы меню, вместо этого они будут конфигурировать объекты меню различными командами.
 
 ### @ Когда вы хотите ставить операции в очередь, выполнять их по расписанию или передавать по сети.
 ### @ Как и любые другие объекты, команды можно сериализовать, то есть превратить в строку, чтобы потом сохранить в файл или базу данных. Затем в любой удобный момент её можно достать обратно, снова превратить в объект команды и выполнить. Таким же образом команды можно передавать по сети, логировать или выполнять на удалённом сервере.
 
 ### @ Когда вам нужна операция отмены.
 ### @ Главная вещь, которая вам нужна, чтобы иметь возможность отмены операций, — это хранение истории. Среди многих способов,  которыми можно это сделать, паттерн Команда является, пожалуй, самым популярным.
 
# Преимущества и недостатки
 
 ### + Убирает прямую зависимость между объектами, вызывающими операции, и объектами, которые их непосредственно выполняют.
 ### + Позволяет реализовать простую отмену и повтор операций.
 ### + Позволяет реализовать отложенный запуск операций.
 ### + Позволяет собирать сложные команды из простых.
 ### + Реализует принцип открытости/закрытости.
 
 ### - Усложняет код программы из-за введения множества дополнительных классов.
  
 # Пример применения
 
 ![Command.Sequence](https://github.com/PavelRudenya730501/Patterns/raw/master/pictures/example(command).png)
 
 В этом примере паттерн Команда служит для ведения истории выполненных операций, позволяя отменять их, если потребуется.
 
 Команды, которые меняют состояние редактора (например, команда вставки текста из буфера обмена), сохраняют копию состояния редактора
 перед выполнением действия. Копии выполненных команд помещаются в историю команд, откуда они могут быть получены, если нужно будет
 сделать отмену операции.

 Классы элементов интерфейса, истории команд и прочие не зависят от конкретных классов команд, так как работают с ними через общий
 интерфейс. Это позволяет добавлять в приложение новые команды, не изменяя существующий код.

// Абстрактная команда задаёт общий интерфейс для конкретных
// классов команд и содержит базовое поведение отмены операции.
abstract class Command is
    protected field app: Application
    protected field editor: Editor
    protected field backup: text

    constructor Command(app: Application, editor: Editor) is
        this.app = app
        this.editor = editor

    // Сохраняем состояние редактора.
    method saveBackup() is
        backup = editor.text

    // Восстанавливаем состояние редактора.
    method undo() is
        editor.text = backup

    // Главный метод команды остаётся абстрактным, чтобы каждая
    // конкретная команда определила его по-своему. Метод должен
    // возвратить true или false в зависимости о того, изменила
    // ли команда состояние редактора, а значит, нужно ли её
    // сохранить в истории.
    abstract method execute()


// Конкретные команды.
class CopyCommand extends Command is
    // Команда копирования не записывается в историю, так как
    // она не меняет состояние редактора.
    method execute() is
        app.clipboard = editor.getSelection()
        return false

class CutCommand extends Command is
    // Команды, меняющие состояние редактора, сохраняют
    // состояние редактора перед своим действием и сигнализируют
    // об изменении, возвращая true.
    method execute() is
        saveBackup()
        app.clipboard = editor.getSelection()
        editor.deleteSelection()
        return true

class PasteCommand extends Command is
    method execute() is
        saveBackup()
        editor.replaceSelection(app.clipboard)
        return true

// Отмена — это тоже команда.
class UndoCommand extends Command is
    method execute() is
        app.undo()
        return falsev

// Глобальная история команд — это стек.
class CommandHistory is
    private field history: array of Command

    // Последний зашедший...
    method push(c: Command) is
        // Добавить команду в конец массива-истории.

    // ...выходит первым.
    method pop():Command is
        // Достать последнюю команду из массива-истории.

// Класс редактора содержит непосредственные операции над
// текстом. Он отыгрывает роль получателя – команды делегируют
// ему свои действия.
class Editor is
    field text: string

    method getSelection() is
        // Вернуть выбранный текст.

    method deleteSelection() is
        // Удалить выбранный текст.

    method replaceSelection(text) is
        // Вставить текст из буфера обмена в текущей позиции.

// Класс приложения настраивает объекты для совместной работы.
// Он выступает в роли отправителя — создаёт команды, чтобы
// выполнить какие-то действия.
class Application is
    field clipboard: string
    field editors: array of Editors
    field activeEditor: Editor
    field history: CommandHistory

    // Код, привязывающий команды к элементам интерфейса, может
    // выглядеть примерно так.
    method createUI() is
        // ...
        copy = function() {executeCommand(
            new CopyCommand(this, activeEditor)) }
        copyButton.setCommand(copy)
        shortcuts.onKeyPress("Ctrl+C", copy)

        cut = function() { executeCommand(
            new CutCommand(this, activeEditor)) }
        cutButton.setCommand(cut)
        shortcuts.onKeyPress("Ctrl+X", cut)

        paste = function() { executeCommand(
            new PasteCommand(this, activeEditor)) }
        pasteButton.setCommand(paste)
        shortcuts.onKeyPress("Ctrl+V", paste)

        undo = function() { executeCommand(
            new UndoCommand(this, activeEditor)) }
        undoButton.setCommand(undo)
        shortcuts.onKeyPress("Ctrl+Z", undo)

    // Запускаем команду и проверяем, надо ли добавить её в
    // историю.
    method executeCommand(command) is
        if (command.execute())
            history.push(command)

    // Берём последнюю команду из истории и заставляем её все
    // отменить. Мы не знаем конкретный тип команды, но это и не
    // важно, так как каждая команда знает, как отменить своё
    // действие.
    method undo() is
        command = history.pop()
        if (command != null)
            command.undo()

## Отношения с другими паттернами

### @ Цепочка обязанностей, Команда, Посредник и Наблюдатель показывают различные способы работы отправителей запросов с их получателями:
Цепочка обязанностей передаёт запрос последовательно через цепочку потенциальных получателей, ожидая, что какой-то из них обработает
запрос. Команда устанавливает косвенную одностороннюю связь от отправителей к получателям. Посредник убирает прямую связь между
отправителями и получателями, заставляя их общаться опосредованно, через себя. Наблюдатель передаёт запрос одновременно всем
заинтересованным получателям, но позволяет им динамически подписываться или отписываться от таких оповещений.

### @ Обработчики в Цепочке обязанностей могут быть выполнены в виде Команд. В этом случае множество разных операций может быть выполнено над одним и тем же контекстом, коим является запрос. Но есть и другой подход, в котором сам запрос является Командой, посланной по цепочке объектов. В этом случае одна и та же операция может быть выполнена над множеством разных контекстов, представленных
в виде цепочки.

### @ Команду и Снимок можно использовать сообща для реализации отмены операций. В этом случае объекты команд будут отвечать за выполнение действия над объектом, а снимки будут хранить резервную копию состояния этого объекта, сделанную перед самым запуском команды.

### @ Команда и Стратегия похожи по духу, но отличаются масштабом и применением:
Команду используют, чтобы превратить любые разнородные действия в объекты. Параметры операции превращаются в поля объекта. Этот объект
теперь можно логировать, хранить в истории для отмены, передавать во внешние сервисы и так далее. С другой стороны, Стратегия описывает
разные способы произвести одно и то же действие, позволяя взаимозаменять эти способы в каком-то объекте контекста.

### @ Если Команду нужно копировать перед вставкой в историю выполненных команд, вам может помочь Прототип.
### @ Посетитель можно рассматривать как расширенный аналог Команды, который способен работать сразу с несколькими видами получателей.
